var tipuesearch = {"pages": [{'title': '關於', 'text': 'https://github.com/mdecycu/cmsite \xa0 \n', 'tags': '', 'url': '關於.html'}, {'title': '作業內容', 'text': '', 'tags': '', 'url': '作業內容.html'}, {'title': 'w2', 'text': '簡單的C程序，必須存成.c的附檔名，因為這個編輯器是交叉副檔名來判定拿哪一個系統來處理你的程序 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n \n \n \n #include <stdio.h> \n \xa0 \xa0 \n int   main( void ) { \n \xa0\xa0 printf ( "Hello World中文\\n" ); \n \xa0\xa0 return   0; \n } \n \n \n \n \n \n \n \n 請利用重複迴圈印出十行相同字串 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n #include <stdio.h> \n \xa0 \n int   main( void ) { \n \xa0\xa0\xa0\xa0 // 設定迴圈執行10次 \n \xa0\xa0\xa0\xa0 for   ( int   i = 0; i < 10; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 // 在每次迴圈中列印相同字串 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 printf ( "Hello World中文\\n" ); \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n \n \n \n \n \n \n 不能將i變數打印出來 \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n #include <stdio.h> \n \xa0 \n int   main( void ) { \n \xa0\xa0\xa0\xa0 // 設定迴圈執行10次 \n \xa0\xa0\xa0\xa0 for   ( int   i = 0; i < 10; i++) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 // 在每次迴圈中列印相同字串與 i 變數的值 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 printf ( "Hello World中文 - Line %d\\n" , i + 1); \n \xa0\xa0\xa0\xa0 } \n \xa0 \n \xa0\xa0\xa0\xa0 return   0; \n } \n \n \n \n \n \n \n \n \n \n stdio.h \xa0 是什麼？ \n \n stdio.h \xa0 是標準輸入輸出頭檔（Standard Input/Output Header）的縮寫。這個頭檔包含了用於輸入和輸出操作的函數，例如和。當你包含時，你使用 這些 函數 來進行控制台輸入和輸出操作。 \xa0 printf \xa0 \xa0 scanf \xa0 <stdio.h> \xa0 \n \n \n \n 為什麼要包括 ？ \xa0 <stdio.h> \n \n 包含 是為了使用標準輸入輸出函數，這樣你就可以使用 和 函數。這些函數是標準C語言提供的基本輸入輸出工具。 \xa0 <stdio.h> \xa0 \xa0 printf \xa0 \xa0 scanf \xa0 \n \n \n \n int \xa0 代表什麼？ \n \n int \xa0 是整數（integer）的縮寫。在 中， 表示 函數將傳回一個整數值。通常，傳回值 表示程式正常結束，而其他值則可能表示錯誤狀態。 \xa0 int main(void) \xa0 int \xa0 \xa0 main \xa0 \xa0 0 \xa0 \n \n \n \n 為什麼每一行一定要鍛鍊「;」？ \n \n 在C++中，分號 (  ; ) 是語句的結束符號。它告訴編譯器這是一條語句的結束。每行結尾都需要加上分號，這是C++語法的一部分。 \n \n \n \n main(void) \xa0 代表什麼？ \n \n 其中 ， 是程式的主函數。 表示 函數不接受任何參數。因此， 表示 函數傳回一個整數值，而且不帶任何參數。 \xa0 int main(void) \xa0 main \xa0 void \xa0 \xa0 main \xa0 int main(void) \xa0 \xa0 main \xa0 \n \n \n \n 編譯和解譯有什麼不同？ \n \n 簡單來說，編譯器是高階語言程式碼轉換為機器碼或執行程式碼的過程，而解釋是逐行執行原始程式碼，消耗生成獨立的可執行檔。C++通常是編譯語言，編譯器將原始碼編譯生成執行檔。解釋語言在運行時解釋和執行原始碼，如Python。 \n \n \n \n', 'tags': '', 'url': 'w2.html'}, {'title': 'w3', 'text': '利用已經有 Brython 執行環境的網關，在設定中取得 Github 課堂第一次作業時，立即進入各個模板，因此只需取得： \n 利用學校帳號，建立Github帳號，以英文姓名加上一組數字，選擇最短的帳號名稱例如：jfk40723199，jfk方便自選的姓名縮寫，而附加則加上各自的學號。 \n 擁有Github帳號後，即可透過Github Classroom作業連結取得作業以太坊，手機在以太坊設定Github Pages後，即可啟用作業網站（以下稱網站皆指靜態網站，而用於編輯網站內容的 動態 網站 ， 則係統稱為互聯網內容編輯器 ，使用動態網站的目的是編輯靜態網站的內容）。 網站內容經過編輯後，必須建立新的網站內容（使用generate_pages），然後將新的網站內容更新到對應的Github 錢包中（稱為改版，其過程經歷 git add、git commit 和 git push 等階段）。 \xa0 \xa0 \n git 為分散式版本次管理系統工具。 \n git新增 \n git 提交 \n git 推送 \n 利用Github教室建立作業以太坊的問題： \n 2023/09/26 在 1a w3 課程進行到建立各練習地點作業時發現，將 Replit 導入 Github 錢包的流程中，所產生的系統間權限設置，必須由 Github 課堂管理帳號（以 cp2023 為例，附屬在mdecp2023 帳戶下），針對各使用者所提出的個別Replit 權限請求（以site-scrum-1 憑證為例，只能穿透Replit 提出控管mdecp2023/site-scrum-1 憑證的權限）逐一進行 設定 。 \xa0 \n \n （上圖顯示共有三個用戶針對mdecp2023 帳戶下的Github Classroom 憑證提出Replit 連線要求，其中只有最上面用戶的請求獲取mdecp2023/site-scrum-1 錢包的維護權限，其餘兩個則請求則尚待解決審核階段。意即若要讓各使用者整合Replit， 每一個Github Classroom作業，管理員都必須手動處理超過兩百則的請求 ） \xa0 \n 為消除管理者的手動設定負擔，決定 2023 cp 與 cad 等課程將放棄使用 Github Classroom。 原本由各學員本人針對課程創建用於評分的課程憑證與網站(cp 課程建立cp2023 證書, cad 課程則建立cad2023 證書), 直接附屬在學員的Github 帳號下, 後續的子模組設定與網關親切權限則統一由各學員自行負責 \n', 'tags': '', 'url': 'w3.html'}, {'title': 'w4', 'text': '各學員自行建立線上考試帳號 \n 選取 112學年第一學期教師課程表 中的學員修課名單，利用Teams中的Excel取得學員Github帳號。 \xa0 \n 各學員自行建立Github評分文件cp2023，並設定Github Pages \n 登入Github後，以\xa0 https://github.com/mdecycu/cmsite \xa0為範本建立 cp2023 錢包 \n 在Replit IDE上啟動cp2023內容編輯網站，將改版內容自動至Github \n 在同時登入 Github 與 Replit 的情況下，將 Replit 帳號連結至 Github 帳號 \n 利用 import 將 cp2023 證件導入 Replit \n 設定 .replit 為 python3 main.py \n 根據 cp2023 錢包中的 README.md 在 Shell 區執行 git submodule 和 pip install \n 以 Run 執行 main.py 啟動以太坊內容編輯網頁 \n 利用 密碼產生程式 將所指定的管理員密碼字符串存入工具-秘密頁面中的設定變數（若無設定環境變數設定，動態網站登入管理員密碼將由錢包中的config/config字符串進行驗證） \n 重新啟動以太坊內容編輯網頁後，以新管理員密碼登入後改版並轉換為靜態內容後，在Git頁面中將改版推至Github \n', 'tags': '', 'url': 'w4.html'}, {'title': 'W5', 'text': '圓形圖方案如下 \n #include <stdio.h>  \n \nint main() {  \n    // 開啟檔案寫入位移與速度資料 \n    FILE *outputFile = fopen("motion_data.txt", "w");  \n    if (!outputFile) {  \n        fprintf(stderr, "建立資料檔失敗。\\n");  \n        返回1； \n    }  \n \n    // 模擬運動10秒並計算位移與速度，同時將資料寫入檔案 \n    double x = 0.2;  // 初始位移 \n    double v = 0.0;  // 初速 \n    double dt = 0.01;  // 時間步 \n    長 double t = 0.0;  // 時間 \n \n    while (t <= 10.0) { \n        雙加速度 = (-10.0 * x - 0.5 * v) / 1.0;  // 這裡修改系統參數 \n        v += 加速度 * dt;  \n        x+=v*dt； \n \n        fprintf(outputFile, "%lf %lf %lf\\n", t, x, v);  \n \n        t += dt； \n    }  \n \n    // 關閉資料檔 \n    fclose(outputFile);  \n \n    // 使用 popen 啟動 Gnuplot 程序 \n    FILE *gnuplotPipe = popen("gnuplot -persistent", "w");  \n    if (!gnuplotPipe) {  \n        fprintf(stderr, "啟動 Gnuplot 失敗。\\n");  \n        返回1； \n    }  \n \n    // 使用 Gnuplot 繪圖指令，指定字體並輸出為 PNG  \n    fprintf(gnuplotPipe, "setterminal pngcairo Innovative font \'default,10\' size 800,400\\n");  \n    fprintf(gnuplotPipe, "設定輸出 \'motion_plot.png\'\\n");  \n    fprintf(gnuplotPipe, "設定標題\'位移與速度與時間\'\\n");  \n    fprintf(gnuplotPipe, "設定 xlabel \'時間 (s)\'\\n");  \n    fprintf(gnuplotPipe, "設定 ylabel \'位移(m)\'\\n");  \n    fprintf(gnuplotPipe, "使用 1:2 行 lw 2 標題 \'位移\' 繪製 \'motion_data.txt\', \\  \n                             \'motion_data.txt\' 使用 1:3 行 lw 2 標題 \'速度\'\\n");  \n \n    // 關閉 Gnuplot 程序 \n    fprintf(gnuplotPipe, "exit\\n");  \n    pclose(gnuplotPipe);  \n \n    返回0； \n} \n 清除 \n 光碟下載 \n 抄送 gnuplot_ex1.c \n ./一個輸出 \n \n', 'tags': '', 'url': 'W5.html'}, {'title': 'w6', 'text': '', 'tags': '', 'url': 'w6.html'}, {'title': '鵬', 'text': 'roc_flag_in_gd.c \xa0原始碼如下 \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17號 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n 105 \n 106 \n 107 \n 108 \n 109 \n 110 \n 111 \n 112 \n 113 \n 114 \n 115 \n 116 \n 117 \n 118 \n 119 \n 120 \n 121 \n 122 \n \n \n \n // https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China \n // 內政部國旗參考資料: https://www.moi.gov.tw/cp.aspx?n=10621 \n // cc roc_flag_in_gd.c -lgd -lm to link with gd and math library \n // https://www.rapidtables.com/web/color/RGB_Color.html \n // 幾何形狀著色與繪圖練習 \n // 以下 gd 繪圖程式嘗試畫出 ROC 國旗, 請根據下列程式內容完成後續的國旗繪圖 \n #include <stdio.h> \n #include <gd.h> \n #include <math.h> \n \xa0 \n void \xa0 draw_roc_flag(gdImagePtr img); \n void \xa0 draw_white_sun(gdImagePtr img, \xa0 int \xa0 x, \xa0 int \xa0 y, \xa0 int \xa0 size, \xa0 int \xa0 color); \n \xa0 \n int \xa0 main() { \n \xa0\xa0\xa0\xa0 // width 3: height 2 \n \xa0\xa0\xa0\xa0 int \xa0 width = 1200; \n \xa0\xa0\xa0\xa0 // 國旗長寬比為 3:2 \n \xa0\xa0\xa0\xa0 int \xa0 height = ( int )(width*2.0 / 3.0); \n \xa0 \n \xa0\xa0\xa0\xa0 gdImagePtr img = gdImageCreateTrueColor(width, height); \n \xa0\xa0\xa0\xa0 gdImageAlphaBlending(img, 0); \n \xa0 \n \xa0\xa0\xa0\xa0 draw_roc_flag(img); \n \xa0 \n \xa0\xa0\xa0\xa0 FILE \xa0 *outputFile = \xa0 fopen ( "./../images/roc_flag_in_gd.png" , \xa0 "wb" ); \n \xa0\xa0\xa0\xa0 if \xa0 (outputFile == NULL) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fprintf (stderr, \xa0 "Error opening the output file.\\n" ); \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return \xa0 1; \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 gdImagePngEx(img, outputFile, 9); \n \xa0\xa0\xa0\xa0 fclose (outputFile); \n \xa0\xa0\xa0\xa0 gdImageDestroy(img); \n \xa0\xa0\xa0\xa0 return \xa0 0; \n } \n \xa0 \n void \xa0 draw_roc_flag(gdImagePtr img) { \n \xa0\xa0\xa0\xa0 int \xa0 width = gdImageSX(img); \n \xa0\xa0\xa0\xa0 int \xa0 height = gdImageSY(img); \n \xa0\xa0\xa0\xa0 int \xa0 red, white, blue; \n \xa0\xa0\xa0\xa0 // 白日位於青天面積正中央, 因此中心點座標為長寬各 1/4 處 \n \xa0\xa0\xa0\xa0 int \xa0 center_x = ( int )(width/4); \n \xa0\xa0\xa0\xa0 int \xa0 center_y = ( int )(height/4); \n \xa0\xa0\xa0\xa0 // gdImageFilledEllipse 需以長寬方向的 diameter 作圖 \n \xa0\xa0\xa0\xa0 // 由於中央白日圓形的半徑為青天寬度的 1/8 \n \xa0\xa0\xa0\xa0 // 因此中央白日圓形的直徑為青天寬度的 1/4, 也就是國旗寬度的 1/8 \n \xa0\xa0\xa0\xa0 // 而且白日十二道光芒的外圍圓形其半徑也是國旗寬度的1/8 \n \xa0\xa0\xa0\xa0 int \xa0 sun_radius = ( int )(width/8); \n \xa0\xa0\xa0\xa0 // 中央白日圓形的直徑等於十二道光芒外圍圓形的半徑 \n \xa0\xa0\xa0\xa0 int \xa0 white_circle_dia = sun_radius; \n \xa0\xa0\xa0\xa0 // 中央藍色圓形半徑為中央白日的 1又 2/15 \n \xa0\xa0\xa0\xa0 int \xa0 blue_circle_dia = white_circle_dia +\xa0 white_circle_dia*2/15; \n \xa0\xa0\xa0\xa0 // 根據 https://www.moi.gov.tw/cp.aspx?n=10621 訂定國旗三種顏色值 \n \xa0\xa0\xa0\xa0 red = gdImageColorAllocate(img, 255, 0, 0); \xa0 // 紅色 \n \xa0\xa0\xa0\xa0 white = gdImageColorAllocate(img, 255, 255, 255); \xa0 // 白色 \n \xa0\xa0\xa0\xa0 blue = gdImageColorAllocate(img, 0, 0, 149); \xa0 // 藍色 \n \xa0\xa0\xa0\xa0 // 根據畫布大小塗上紅色長方形區域 \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(img, 0, 0, width, height, red); \n \xa0\xa0\xa0\xa0 // 青天面積為整面國旗的 1/4, 也是採用長方形塗色 \n \xa0\xa0\xa0\xa0 gdImageFilledRectangle(img, 0, 0, ( int )(width/2.0), ( int )(height/2.0), blue); \n \xa0\xa0\xa0\xa0 // 先設法以填色畫出六個白色堆疊菱形 \n \xa0\xa0\xa0\xa0 draw_white_sun(img, center_x, center_y, sun_radius, white); \n \xa0\xa0\xa0\xa0 // 利用一個藍色大圓與白色小圓畫出藍色環狀 \n \xa0\xa0\xa0\xa0 gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue); \n \xa0\xa0\xa0\xa0 gdImageFilledEllipse(img, center_x, center_y, white_circle_dia, white_circle_dia, white); \n \xa0\xa0 \xa0 \n } \n \xa0 \n void \xa0 draw_white_sun(gdImagePtr img, \xa0 int \xa0 center_x, \xa0 int \xa0 center_y, \xa0 int \xa0 sun_radius, \xa0 int \xa0 color) { \n \xa0\xa0\xa0\xa0 // M_PI 大小定義於 math.h 標頭檔中, 因為三角函數中採用徑度為角度單位 \n \xa0\xa0\xa0\xa0 // 因此定義將角度轉為徑度的轉換變數為 deg, 角度值乘上 deg 就可轉為徑度 \n \xa0\xa0\xa0\xa0 float \xa0 deg = M_PI/180; \n \xa0\xa0\xa0\xa0 // 根據十二道光芒的每一尖角的角度為 15 度, 求出其對應直角三角形的另一角度為 75 度 \n \xa0\xa0\xa0\xa0 // 求出十二道光芒中任一菱形的 small radius, 也就是菱形的另一個對應小圓的半徑大小 \n \xa0\xa0\xa0\xa0 float \xa0 sr = sun_radius/ tan (75*deg); \n \xa0\xa0\xa0\xa0 int \xa0 ax, ay, bx, by, dx, dy, ex, ey; \n \xa0\xa0\xa0\xa0 gdPoint points[4]; \n \xa0\xa0\xa0\xa0 /* 在塗上十二道光芒中的單一菱形區域之前, 先以座標點畫線測試是否正確 \n \xa0\xa0\xa0\xa0 ax = center_x; \n \xa0\xa0\xa0\xa0 ay = center_y - sun_radius; \n \xa0\xa0\xa0\xa0 bx = center_x - sun_radius*tan(15*deg); \n \xa0\xa0\xa0\xa0 by = center_y; \n \xa0\xa0\xa0\xa0 ex = center_x; \n \xa0\xa0\xa0\xa0 ey = center_y + sun_radius; \n \xa0\xa0\xa0\xa0 dx = center_x + sun_radius*tan(15*deg); \n \xa0\xa0\xa0\xa0 dy = center_y; \n \xa0\xa0\xa0\xa0 // AB \n \xa0\xa0\xa0\xa0 gdImageLine(img, ax, ay, bx, by, color); \n \xa0\xa0\xa0\xa0 // BE \n \xa0\xa0\xa0\xa0 gdImageLine(img, bx, by, ex, ey, color); \n \xa0\xa0\xa0\xa0 // ED \n \xa0\xa0\xa0\xa0 gdImageLine(img, ex, ey, dx, dy, color); \n \xa0\xa0\xa0\xa0 // DA \n \xa0\xa0\xa0\xa0 gdImageLine(img, dx, dy, ax, ay, color); \n \xa0\xa0\xa0\xa0 */ \n \xa0\xa0\xa0\xa0 ax = center_x; \n \xa0\xa0\xa0\xa0 ay = center_y - sun_radius; \n \xa0\xa0\xa0\xa0 bx = center_x - sun_radius* tan (15*deg); \n \xa0\xa0\xa0\xa0 by = center_y; \n \xa0\xa0\xa0\xa0 ex = center_x; \n \xa0\xa0\xa0\xa0 ey = center_y + sun_radius; \n \xa0\xa0\xa0\xa0 dx = center_x + sun_radius* tan (15*deg); \n \xa0\xa0\xa0\xa0 dy = center_y; \n \xa0\xa0\xa0\xa0 // 確定單一菱形區域的塗色正確後, 利用迴圈每次轉動 30 度, 總共轉六次即可塗上十二道光芒區域 \n \xa0\xa0\xa0\xa0 for \xa0 ( int \xa0 i=1;i<=6;i++){ \n \xa0\xa0\xa0\xa0 // A \n \xa0\xa0\xa0\xa0 points[0].x = ax+sun_radius* sin (30*deg*i); \n \xa0\xa0\xa0\xa0 points[0].y = ay+sun_radius-sun_radius* cos (30*deg*i); \n \xa0\xa0\xa0\xa0 // B \n \xa0\xa0\xa0\xa0 points[1].x = bx+sr-sr* cos (30*deg*i); \n \xa0\xa0\xa0\xa0 points[1].y = by-sr* sin (30*deg*i); \n \xa0\xa0\xa0\xa0 // E \n \xa0\xa0\xa0\xa0 points[2].x = ex-sun_radius* sin (30*deg*i); \n \xa0\xa0\xa0\xa0 points[2].y = ey-(sun_radius-sun_radius* cos (30*deg*i)); \n \xa0\xa0\xa0\xa0 // D \n \xa0\xa0\xa0\xa0 points[3].x = dx-(sr-sr* cos (30*deg*i)); \n \xa0\xa0\xa0\xa0 points[3].y = dy+sr* sin (30*deg*i); \n \xa0\xa0\xa0\xa0 // 對菱形區域範圍塗色 \n \xa0\xa0\xa0\xa0 gdImageFilledPolygon(img, points, 4, color); \n \xa0\xa0\xa0\xa0 // 在菱形區域外圍畫線, 明確界定菱形範圍 \n \xa0\xa0\xa0\xa0 gdImagePolygon(img, points, 4, color); \n \xa0\xa0\xa0\xa0 } \n } \n \n \n \n \n \n 結果如下 \n \n \n', 'tags': '', 'url': '鵬.html'}, {'title': '美國', 'text': '課程如下 \n #include <stdio.h>  \n#include <math.h>  \n#include <gd.h>  \n \nvoid draw_usa_flag(gdImagePtr img);  \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, double spin_angle);  \n \nint main() {  \nint 寬度 = 800;  \nint 高度 = (int)(寬度 / 1.9);  \n \ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  \ngdImageAlphaBlending(img, 0);  \n \n繪製_美國_標誌（img）； \n \nFILE *outputFile = fopen("./../images/usa_flag.png", "wb");  \nif (outputFile == NULL) {  \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n返回1； \ngdImagePngEx  \n \n(img, 輸出檔, 9);  \nfclose(輸出檔);  \ngdImageDestroy(img);  \n \n返回0； \n}  \n \nvoid draw_usa_flag(gdImagePtr img) {  \nint width = gdImageSX(img);  \nint 高度 = gdImageSY(img);  \nint 紅、白、藍； \n// 國旗顏色 \nred = gdImageColorAllocate(img, 178, 34, 52);  // 條紋紅 \nwhite = gdImageColorAllocate(img, 255, 255, 255);  // 白色條紋 \nblue = gdImageColorAllocate(img, 60, 59, 110);  // 藍色 \n \nint stripe_height = height / 13;  \nint stripe_width = 寬度； \nint star_size = (int)(0.0308 * 高度);  // 星星大小 \n \nfor (int y = 0; y < height; y += stripe_height) {  \nif (y / stripe_height % 2 == 0) {  \ngdImageFilledRectangle(img, 0, y, stripe_width, y + str.  \n} else {  \ngdImageFilledRectangle(img, 0, y, stripe_width, y + stripe_height, 白色);  \ngdImageFilledRectangle  \n(img, 0, 0, 寬度 * 2 / 5, stripe_height * 7, 藍色)  \n;  \nint star_spacing_x = (int)(0.129 * 高度);  // 橫向星星之間的間距 \nint star_spacing_y = (int)(0.054 * height);  // 縱向星星之間的距離 \nint star_start_x = (int)(0.125 * height);  // 星星的起始X位置 \nint star_start_y = (int)(0.0485 * height);  // 星星的起始Y位置 \nfor (int row = 0; row < 9; row++) {  \nint starPerRow = (row % 2 == 0) ?  6：5； \n// 計算2、4、6和8排星星的偏移量 \nint offset_x = (row % 2 == 0) ?  star_spacing_x / -2 : 0;  \nfor (int star = 0; star < starPerRow; star++) {  \nint x = star_start_x + star * star_spacing_x + offset_x;  \n// 旋轉角度（以弧度為單位） \ndoublerotation_angle = M_PI / 5;  // 忘記旋轉的度數 \nint y = star_start_y + row * star_spacing_y;  \ndraw_star(img, x, y, star_size, 白色, 旋轉角度);  \nvoid  \ndraw_star (gdImagePtr img, int x,  \nint  \ny, int size, int color, doublerotation_angle) {  \ngdPoint 點[10];  \nfor (int i = 0; i < 10; i++) { \n雙倍角度 = M_PI / 2 + i * 2 * M_PI / 10 + 旋轉角度;  \nint 半徑 = (i % 2 == 0) ?  尺寸：尺寸/2； \n \n \n \n \n \n \n \n \n \n點[i].x = x + 半徑 * cos(角);  \n點[i].y = y + 半徑 * sin(角);  \n}  \n \n// 使用指定的顏色填滿星星 \ngdImageFilledPolygon(img,points,10,color);  \n} \n \n 結果如下 \n \n', 'tags': '', 'url': '美國.html'}, {'title': '日本', 'text': '課程如下 \n \n #include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n \nvoid draw_japan_flag(gdImagePtr img);  \nvoid draw_red_sun(gdImagePtr img, int x, int y, int size, int color);  \n \nint main() {  \nint 原始寬度 = 1200;  \nint 原高度 = (int)(原寬度 * 2.0 / 3.0);  \ngdImagePtr img = gdImageCreateTrueColor(originalWidth,originalHeight);  \ngdImageAlphaBlending(img, 0);  \n \n繪製_日本_標誌（img）； \n \n// 新的寬度和高度以適應“images”資料夾 \nint newWidth = 600;  \nint newHeight = (int)(newWidth * 2.0 / 3.0);  \n \n//建立新映像並進行縮放 \ngdImagePtr resizedImage = gdImageCreateTrueColor(newWidth, newHeight);  \ngdImageAlphaBlending(resizedImage, 0);  \ngdImageCopyResampled（調整大小的映像，img，0,0,0,0，newWidth，newHeight，originalWidth，originalHeight）； \n \nFILE *outputFile = fopen("./../images/japan_flag.png", "wb");  \nif (outputFile == NULL) {  \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n返回1； \ngdImagePng  \n(resizedImage, 輸出檔);  \nfclose(輸出檔);  \ngdImageDestroy(img);  \ngdImageDestroy(調整大小的圖像);  \n \n返回0； \n}  \n \nvoid draw_japan_flag(gdImagePtr img) {  \nint width = gdImageSX(img);  \nint 高度 = gdImageSY(img);  \n \n// 建立一個白色背景 \nint white = gdImageColorAllocate(img, 255, 255, 255);  \ngdImageFilledRectangle(img, 0, 0, 寬度 - 1, 高度 - 1, 白色);  \n \n// 對應紅色商品（太陽） \nint red = gdImageColorAllocate(img, 255, 0, 0);  \nint center_x = 寬度 / 2;  \nint center_y = 高度 / 2;  \nint 半徑 = (int)((寬度 * 2) / 3);  \ndraw_red_sun(img, center_x, center_y, 半徑, 紅色);  \n}  \n \nvoid draw_red_sun(gdImagePtr img, int x, int y, int size, int color) {  \n// 減少 size 的值，例如將他的值減半 \nsize = size / 2;  \ngdImageArc(img, x, y, 尺寸, 尺寸, 0, 360, 顏色);  \ngdImageFillToBorder(img, x, y, 顏色, 顏色);  \n} \n \n', 'tags': '', 'url': '日本.html'}, {'title': '英國', 'text': '#include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n \nvoid draw_uk_flag(gdImagePtr img);  \nvoid fillTriangle(gdImagePtr img, int x1, int y1, int x2, int y2, int x3, int y3, int color);  \n \nint main() {  \n    // 國旗的寬與高 \n    int width = 1200;  \n    int 高度 = 寬度 / 2;  \n \n    //映像建立 \n    gdImagePtr img = gdImageCreateTrueColor(width, height);  \n    gdImageAlphaBlending(img, 0);  \n \n    // 鄰近英國國旗 \n    draw_uk_flag(img);  \n \n    // 將圖片儲存到檔案 \n    FILE *outputFile = fopen("./../images/uk_flag.png", "wb");  \n    if (outputFile == NULL) {  \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n        返回1； \n    gdImagePngEx  \n    (img, 輸出檔, 9);  \n    fclose(輸出檔);  \n    gdImageDestroy(img);  \n    返回0； \n}  \n\n\n \nvoid draw_uk_flag(gdImagePtr img) {  \n    int width = gdImageSX(img);  \n    int 高度 = gdImageSY(img);  \n \n    int 紅、白、藍； \n    紅色 = gdImageColorAllocate(img, 204, 0, 0);  // 紅色 \n    white = gdImageColorAllocate(img, 255, 255, 255);  // 白色 \n    藍色 = gdImageColorAllocate(img, 0, 0, 153);  // 藍色 \n \n    gdImageFilledRectangle(img, 0, 0, 寬度, 高度, 藍色);  \n\n \n  int x1, y1, x2, y2, x3, y3;  \n  {  \n    int 線厚 = 100;  \n    gdImageSetThickness(img, line_thickness);  \n \n    int x1, y1, x2, y2, x3, y3;  \n \n    // 鄰近白色斜線 \n    x1 = 0;  \n    y1 = 600； \n    x2 = 1200； \n    y2=0； \n    gdImageLine(img, x1, y1, x2, y2, 白色);  \n \n    x1=0； \n    y1=0； \n    x2 = 1200； \n    y2 = 600； \n    gdImageLine(img, x1, y1, x2, y2, 白色);  \n}  \n  {  \n    int line_thickness = 33;  \n    gdImageSetThickness(img, line_thickness);  \n\n \n    // 各地紅色斜線 \n    x1 = 566;  \n    y1 = 300； \n    x2 = 1166； \n    y2=0； \n    gdImageLine(img, x1, y1, x2, y2, 紅色);  \n \n    x1 = 1233； \n    y1 = 600； \n    x2 = 633； \n    y2 = 300； \n    gdImageLine(img, x1, y1, x2, y2, 紅色);  \n \n    x1 = 566； \n    y1 = 300； \n    x2 = -33;  \n    y2=0； \n    gdImageLine(img, x1, y1, x2, y2, 紅色);  \n \n    x1 = 600； \n    y1 = 316.5； \n    x2 = 0； \n    y2 = 616.5； \n    gdImageLine(img, x1, y1, x2, y2, 紅色);  \n  }  \n  {  \n  int line_thickness = 33;  \n  gdImageSetThickness(img, line_thickness); \n \n  int x1, y1, x2, y2, x3, y3;  \n \n  // 勢弱斜線 \n  x1 = 0;  \n  y1 = 600； \n  x2 = 1200； \n  y2=0； \n  gdImageLine(img, x1, y1, x2, y2, 紅色);  \n\n \n  x1 = 1200； \n    y1 = 16.5； \n    x2 = 600； \n    y2 = 316.5； \n    gdImageLine(img, x1, y1, x2, y2, 白色);  \n\n \n  x1=0； \n    y1 = 583.5； \n    x2 = 600； \n    y2 = 283.5； \n    gdImageLine(img, x1, y1, x2, y2, 白色);  \n\n \n  }  \n \n    // 白色十字 \n    int cross_width = width / 32;  \n    int cross_arm_width = 寬度 / 32;  \n    int center_x = 寬度 / 2;  \n    int center_y = 高度 / 2;  \n \n    gdImageFilledRectangle(img, center_x + 2.7 * cross_width, 0, center_x - 2.7 * cross_width, 高度, 白色);  \n    gdImageFilledRectangle(img, 0, center_y + 2.7 * cross_arm_width, 寬度, center_y - 2.7 * cross_arm_width, 白色);  \n \n    // 同等紅十字 \n    gdImageFilledRectangle(img, center_x + 1.5 * cross_width, 0, center_x - 1.5 * cross_width, height, red);  \n    gdImageFilledRectangle(img, 0, center_y + 1.5 * cross_arm_width, 寬度, center_y - 1.5 * cross_arm_width, 紅色);  \n} \n \n', 'tags': '', 'url': '英國.html'}, {'title': '過程', 'text': '#include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n \nvoid draw_chinese_flag(gdImagePtr img);  \n \nint main() {  \n    int 寬度 = 300;  // 國旗寬度 \n    int height = 200;  // 國旗高度 \n \n    gdImagePtr im = gdImageCreateTrueColor(width, height);  \n    gdImageAlphaBlending(im, 0);  \n \n    繪製中文標誌（im）； \n \n    FILE *outputFile = fopen("./../images/proc_flag.png", "wb");  \n    if (outputFile == NULL) {  \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n        返回1； \n    gdImagePngEx  \n \n    (im, 輸出檔, 9);  \n    fclose(輸出檔);  \n    gdImageDestroy(im);  \n \n    返回0； \n}  \n \n// 宣告draw_star 函式 \nvoid draw_star(gdImagePtr img, int x, int y, int size, int color, doublerotation_angle);  \n \n無效draw_chinese_flag(gdImagePtr img) {  \n    int width = gdImageSX(img);  \n    int 高度 = gdImageSY(img);  \n    int 紅色、黃色； \n \n    // 國旗顏色 \n    red = gdImageColorAllocate(img, 255, 0, 0);  // 紅色背景 \n    yellow = gdImageColorAllocate(img, 255, 255, 0);  // 黃色星星 \n \n    // 畫紅色背景 \n    gdImageFilledRectangle(img, 0, 0, width, height, red);  \n \n    // 設定星星的大小與位置 \n    int star_size = (int)(0.28 * height);  \n    int star_x = (int)(0.165 * 寬度);  \n    int star_y = (int)(0.265 * 高度);  \n \n    // 畫大星星 \n    draw_star(img, star_x, star_y, star_size, Yellow, 11.0);  \n \n    // 鄰近小恆星，位置依實際國旗比例計算 \n    double radius = 0.15 * height;  \n    雙倍角度 = 360 / 7 * M_PI / 179.0； \n    雙旋轉 = -M_PI / 7.5； \n    int cx = (int)(0.32 * 寬度);  \n    int cy = (int)(0.27 * 高度);  \n \n    for (int i = -1; i < 3; i++) {  \n        int x = (int)(cx + 半徑 * cos(i * 角度 + 旋轉));  \n        int y = (int)(cy + 半徑 * sin(i * 角度 + 旋轉));  \n        draw_star(img, x, y, 19, 黃色, M_PI / 5.0);  \n    void draw_star(gdImagePtr img, int x,  \nint  \n \ny, int size, int color, doublerotation_angle) {  \n    gdPoint 點[10];  \n \n    // 計算星形的五個外點和五個內點 \n    double outer_radius = size / 2;  \n    雙內半徑 = 大小 / 6； \n    雙倍角度 = M_PI / 5.0； \n \n    for (int i = 0; i < 10; i++) { \n        雙半徑 = (i % 2 == 0) ?  外半徑：內半徑； \n        雙 theta = 旋轉角度 + i * 角度； \n        點[i].x = x + 半徑 * cos(theta);  \n        點[i].y = y + 半徑 * sin(theta);  \n    }  \n \n    // 使用 gdImageFilledPolygon 較差星形 \n    gdImageFilledPolygon(img, 點, 10, 顏色);  \n} \n \n', 'tags': '', 'url': '過程.html'}, {'title': '韓國', 'text': '#include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n \n#define WIDTH 900  \n#define HEIGHT 600  \n#define FILENAME "south_korea_flag.png"  \n \nint main() {  \n    gdImagePtr im;  \n    文件 *pngout;  \n    int 白色、黑色、紅色、藍色； \n \n    im = gdImageCreate(寬度, 高度);  \n \n    白色 = gdImageColorAllocate(im, 255, 255, 255);  \n    黑色 = gdImageColorAllocate(im, 0, 0, 0);  \n    紅色 = gdImageColorAllocate(im, 205, 0, 0);  \n    藍色 = gdImageColorAllocate(im, 0, 56, 168);  \n \n    // 背景（白色） \n    gdImageFilledRectangle(im, 0, 0, WIDTH, HEIGHT , 白色);  \n \n    // 藍色圓（陰陽符號） \n    gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 210, 30, red, gdArc);  \n \n    // 紅色圓圈（陰陽符號） \n    gdImageFilledArc(im, WIDTH / 2, HEIGHT / 2, WIDTH / 3, HEIGHT / 2, 30, 210, blue, gdArc);  \n \n  int 圓 X = 385;  // 圓心的 X 座標 \n  int CircleY = 262.5;  // 圓心的 Y 座標 \n  int CircleRadius = 75;     \n \n  // 圓形 \n  gdImageFilledEllipse(im,circleX,circleY,circleRadius * 2,circleRadius * 2,red);  \n \n  int 圓X2 = 515;  // 圓心的 X 座標 \n \n int CircleY2 = 337.5;  \n \n  // 圓形 \n  gdImageFilledEllipse(im,circleX2,circleY2,circleRadius * 2,circleRadius * 2,blue);  \n \n  {  \n\n \n  // 起點與終點位置 \n \n  int startX = 340;    \n  // 線的起點 X 座標 \n \n  int startY = 90;   \n  // 線的起點 Y 座標 \n \n  int endX = 200;     \n  // 線的終點 X 座標 \n \n  int endY = 260;     \n  // 線的終點 Y 座標 \n \n  int lineWidth = 23;  // 線的寬度 \n \n  // 有多線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX, startY, endX, endY, 黑色);  \n  // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX -35, startY -10, endX -35, endY -10, 黑色);  \n \n  // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX -70, startY -20, endX -70, endY -20, 黑色);  \n \n  int startX2 = 213;    \n  // 線的起點 X 座標 \n \n  int startY2 = 270;   \n  // 線的起點 Y 座標 \n \n  int endX2 = 133;     \n  // 線的終點 X 座標 \n \n  int endY2 = 210;     \n  // 線的終點 Y 座標 \n \n  int lineWidth2 = 25;  // 線的寬度 \n \n  // 有多線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX2 +3, startY2, endX2 +3, endY2, 白色);  \n \n  gdImageSetThickness(im, lineWidth +10);  \ngdImageLine(im, startX2 -17, startY2 +9 , endX2 -17, endY2 +9 , 白色);  \n \n  gdImageSetThickness(im, lineWidth ); \ngdImageLine(im, startX2 +115, startY2 -145, endX2 +115, endY2 -145, 白色);  \n \n  gdImageSetThickness(im, lineWidth);  \ngdImageLine(im, startX2 +120, startY2 -155, endX2 +120, endY2 -155, 白色);  \n \n  gdImageSetThickness(im, lineWidth +12);  \ngdImageLine(im, startX2 +145, startY2 -155, endX2 +145, endY2 -155, 白色);  \n}  \n  {  \n    // 起點與終點位置 \n \n  int startX = 330;    \n  // 線的起點 X 座標 \n \n  int startY = 520;   \n  // 線的起點 Y 座標 \n \n  int endX = 190;     \n  // 線的終點 X 座標 \n \n  int endY = 350;     \n  // 線的終點 Y 座標 \n \n  int lineWidth = 23;  // 線的寬度 \n \n  // 有多線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX, startY, endX, endY, 黑色);  \n  // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX -35, startY +10, endX -35, endY +10, 黑色);  \n \n  // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX -70, startY +20, endX -70, endY +20, 黑色);  \n \n  int startX2 = 213;    \n  // 線的起點 X 座標 \n \n  int startY2 = 330;   \n  // 線的起點 Y 座標 \n \n  int endX2 = 133;     \n  // 線的終點 X 座標 \n \n  int endY2 = 390;     \n  // 線的終點 Y 座標 \n \n  int lineWidth2 = 25;  // 線的寬度 \n \n  // 位弱線段 \n  gdImageSetThickness(im, lineWidth +8);  \n  gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, 白色);  \n \n  gdImageSetThickness(im, lineWidth +10);  \ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , 白色);  \n \n  gdImageSetThickness(im, lineWidth );  \ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, 白色);  \n \n  gdImageSetThickness(im, lineWidth);  \ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, 白色);  \n \n  gdImageSetThickness(im, lineWidth +14);  \ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, 白色);  \n \n    gdImageSetThickness(im, lineWidth -10);  \ngdImageLine(im, 232, 426, 206, 448, 白色);  \n \n  }  \n \n  {  \n    // 起點與終點位置 \n \n  int startX = 564;    \n  // 線的起點 X 座標 \n \n  int startY = 520;   \n  // 線的起點 Y 座標 \n \n  int endX = 704;     \n  // 線的終點 X 座標 \n \n  int endY = 350;     \n  // 線的終點 Y 座標 \n \n  int lineWidth = 23;  // 線的寬度 \n \n  // 有多線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX +70, startY +20, endX +70, endY +20, 黑色);  \n \n    // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX, startY, endX, endY, 黑色); \n \n    // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX +35, startY +10, endX +35, endY +10, 黑色);  \n \ngdImageSetThickness(im, lineWidth -10);  \ngdImageLine(im, 624, 400, 734, 490, 白色);  \n \n  int startX2 = 553;    \n  // 線的起點 X 座標 \n \n  int startY2 = 330;   \n  // 線的起點 Y 座標 \n \n  int endX2 = 633;     \n  // 線的終點 X 座標 \n \n  int endY2 = 390;     \n  // 線的終點 Y 座標 \n \n  int lineWidth2 = 25;  // 線的寬度 \n \n  // 位弱線段 \n  gdImageSetThickness(im, lineWidth +8);  \n  gdImageLine(im, startX2 +139, startY2, endX2 +139, endY2, 白色);  \n \n  gdImageSetThickness(im, lineWidth +10);  \ngdImageLine(im, startX2 +157, startY2 -9 , endX2 +157, endY2 -9 , 白色);  \n \n  gdImageSetThickness(im, lineWidth);  \ngdImageLine(im, startX2 +25, startY2 +155, endX2 +25, endY2 +155, 白色);  \n \n  gdImageSetThickness(im, lineWidth +30);  \ngdImageLine(im, startX2 -3, startY2 +170, endX2 , endY2 +170, 白色);  \n  }  \n  {  \n    // 起點與終點位置 \n \n  int startX = 330;    \n  // 線的起點 X 座標 \n \n  int startY = 520;   \n  // 線的起點 Y 座標 \n \n  int endX = 190;     \n  // 線的終點 X 座標 \n \n  int endY = 350;     \n  // 線的終點 Y 座標 \n \n  int lineWidth = 23;  // 線的寬度 \n \n  // 有多線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX, startY, endX, endY, 黑色);  \n  // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX -35, startY +10, endX -35, endY +10, 黑色);  \n \n  // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX -70, startY +20, endX -70, endY +20, 黑色);  \n \n  int startX2 = 213;    \n  // 線的起點 X 座標 \n \n  int startY2 = 330;   \n  // 線的起點 Y 座標 \n \n  int endX2 = 133;     \n  // 線的終點 X 座標 \n \n  int endY2 = 390;     \n  // 線的終點 Y 座標 \n \n  int lineWidth2 = 25;  // 線的寬度 \n \n  // 位弱線段 \n  gdImageSetThickness(im, lineWidth +8);  \n  gdImageLine(im, startX2 -11, startY2, endX2 -11, endY2, 白色);  \n \n  gdImageSetThickness(im, lineWidth +10);  \ngdImageLine(im, startX2 -30, startY2 -9 , endX2 -30, endY2 -9 , 白色);  \n \n  gdImageSetThickness(im, lineWidth );  \ngdImageLine(im, startX2 +100, startY2 +150, endX2 +100, endY2 +150, 白色);  \n \n  gdImageSetThickness(im, lineWidth);  \ngdImageLine(im, startX2 +120, startY2 +155, endX2 +120, endY2 +155, 白色);  \n \n  gdImageSetThickness(im, lineWidth +14);  \ngdImageLine(im, startX2 +145, startY2 +157, endX2 +145, endY2 +157, 白色); \n \n    gdImageSetThickness(im, lineWidth -10);  \ngdImageLine(im, 232, 426, 206, 448, 白色);  \n \n  }  \n  {  \n    // 起點與終點位置 \n \n  int startX = 564;    \n  // 線的起點 X 座標 \n \n  int startY = 97;   \n  // 線的起點 Y 座標 \n \n  int endX = 704;     \n  // 線的終點 X 座標 \n \n  int endY = 267;     \n  // 線的終點 Y 座標 \n \n  int lineWidth = 23;  // 線的寬度 \n \n  // 有多線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX +70, startY -20, endX +70, endY -20, 黑色);  \n \n    // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX, startY, endX, endY, 黑色);  \n \n    gdImageSetThickness(im, lineWidth -10);  \ngdImageLine(im, 624, 212, 734, 118, 白色);  \n \n    // 勢弱線段 \n  gdImageSetThickness(im, lineWidth);  \n  gdImageLine(im, startX +35, startY -10, endX +35, endY -10, 黑色);  \n \n  int startX2 = 553;    \n  // 線的起點 X 座標 \n \n  int startY2 = 277;   \n  // 線的起點 Y 座標 \n \n  int endX2 = 633;     \n  // 線的終點 X 座標 \n \n  int endY2 = 217;     \n  // 線的終點 Y 座標 \n \n  int lineWidth2 = 25;  // 線的寬度 \n \n  // 位弱線段 \n  gdImageSetThickness(im, lineWidth +8);  \n  gdImageLine(im, startX2 +134, startY2, endX2 +134, endY2, 白色);  \n \n  gdImageSetThickness(im, lineWidth +10);  \ngdImageLine(im, startX2 +157, startY2 +9 , endX2 +157, endY2 +9 , 白色);  \n \n  gdImageSetThickness(im, lineWidth);  \ngdImageLine(im, startX2 +25, startY2 -155, endX2 +25, endY2 -155, 白色);  \n \n    gdImageSetThickness(im, lineWidth +30);  \ngdImageLine(im, startX2 -5, startY2 -155, endX2 -5, endY2 -155, 白色);  \n \n  }  \n \n    // 儲存圖片 \nFILE *outputFile = fopen("./../images/korea_flag.png", "wb");  \nif (outputFile == NULL) {  \n    fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n    返回1； \ngdImagePngEx  \n  (im, 輸出檔, 9);  \n      fclose(輸出檔);  \n      gdImageDestroy(im);  \n      返回0； \n  } \n \n', 'tags': '', 'url': '韓國.html'}, {'title': 'w7', 'text': '地圖：網站地圖 網站所有頁面 \n EditA：編輯所有頁面，使用時機為（1）解決多人佔用網站時的衝突，或（2）刪除特定頁面 \n 編輯：編輯一頁，先選頁面，再選編輯才能進入編輯模式 \n Config: 編輯網站標題,要編輯網站標題,必須更改 init.py 中的 site_title 字符串內容 \n 搜尋：頁面資料 html 原始碼內容搜尋 \n IUpload：圖片上傳、圖片檔案上傳、資料會放入圖片目錄中 \n IList：圖片檔案列表，首發存在圖片目錄下的圖片文件 \n FUpload：檔案上傳、一般檔案上傳功能、資料會放入下載 目錄中 \n FList：檔案列表，啟動位於下載目錄下的文件 \n 登出：登出 \n 轉換：將config/content.htm經過分頁程式處理後，轉為content目錄下的超文件 \n', 'tags': '', 'url': 'w7.html'}, {'title': 'W10', 'text': '線上簡報、網誌與多媒體影片製作工具： \n Leo Editor \xa0 （ 討論群組 ）為大綱管理系統，可使用程式開發的IDE（整合開發環境）使用，可用於編輯reveal.js 簡報檔案中的html 與 markdown，也可用於編輯 Pelican 網誌 markdown 與轉文件，以及在電腦輔助設計分析過程中，可以用來讀取CoppeliaSim XML 格式檔案。 \n 由於 Python 3.12.0 環境下 Leo Editor 還無法正常查看 pip 安裝，因此必須手動安裝 PyQt5 之後，重新使用 pip install leo，所完成的 Python 3.12.0: Python312_leo_664_PyQt5.7z\xa0  ( \xa0 需要下載密碼) \n Wink \xa0 為操作流程影片製作套件，可在電腦操作過程中，儲存關鍵頁面與鼠標點選區域後，加上輔助文字說明後製作成mp4影片檔。 \n ShareX \xa0 為螢幕畫面抓取像或錄影套件，可以抓取電腦畫面任一區域存為影像文件，或結合語音說明與鼠標操作錄製說明影片。 \n OBS \xa0 為電腦廣播製作系統，可結合各種語音、影像與影片製作出多元的電腦操作說明影片。 \n Wink 和 ShareX 都需要 ffmpeq.exe 。 \xa0 \n', 'tags': '', 'url': 'W10.html'}, {'title': 'w12', 'text': '\n #include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n  \n// 宣告旋轉函數 \nvoidrotateFilledPolygon(int x_orig, int y_orig, doublerotation_ang, gdPoint *points, int num_points) {  \n    int i;  \n    雙角度_rad = 旋轉_ang * M_PI / 180.0； \n  \n    for (i = 0; i < num_points; i++) {  \n        int x = 點[i].x - x_orig;  \n        int y = 點[i].y - y_orig； \n  \n        點[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));  \n        點[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));  \n    }  \n}  \n  \nint main() {  \n    int 寬度 = 800;  \n    整數高度=600； \n  \n    gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  \n    gdImageAlphaBlending(img, 0);  \n  \n    FILE *outputFile = fopen("hellogd1.png", "wb");  \n    if (outputFile == NULL) {  \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n        返回1； \n    int  \n  \n    red = gdImageColorAllocate(img, 255, 0, 0);  \n    int 藍色 = gdImageColorAllocate(img, 0, 0, 255);  \n    int black = gdImageColorAllocate(img, 0, 0, 0);  \n    int 白色 = gdImageColorAllocate(img, 255, 255, 255);  \n  \n    gdImageFilledRectangle(img, 0, 0, 寬度, 高度, 白色);  \n    gdImageFilledRectangle(img, 0, 0, (int)寬度 / 4, (int)高度 / 4, 藍色);  \n  \n    gdImageFilledEllipse(img, (int)寬度 * 3 / 4, (int)高度 / 4, (int)寬度 / 4, (int)寬度 / 4, 紅色);  \n    gdImageEllipse(img, (int)寬度 * 3 / 4, (int)高度 * 3 / 4, (int)寬度 / 4, (int)寬度 / 4, 紅色);  \n    gdImageLine(img, (int)寬度 / 2, (int)高度 / 2, (int)寬度 / 2, (int)高度 / 2 + 100, 藍色);  \n  \n    gdPoint點[4]； \n    點[0].x = (int)寬度 / 4;  \n    點[0].y = (int)高度 * 3 / 4;  \n    點[1].x = 點[0].x + 100； \n    點[1].y = 點[0].y;  \n    點[2].x = 點[1].x； \n    點[2].y = 點[1].y + 100； \n    點[3].x = 點[2].x - 100； \n    點[3].y = 點[2].y;  \n  \n    // 呼叫旋轉函數 \n    rotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 45.0, points, 4);  \n    gdImagePolygon(img, 點, 4, 黑色);  \n  \n    gdPoint點2[4]； \n    點2[0].x = (int)寬度/3;  \n    點2[0].y = (int)高度/2;  \n    點2[1].x = 點2[0].x + 100； \n    點2[1].y = 點2[0].y;  \n    點2[2].x = 點2[1].x;  \n    點2[2].y = 點2[1].y + 100； \n    點2[3].x = 點2[2].x - 150； \n    點2[3].y = 點2[2].y; \n  \n    // 呼叫旋轉函數 \n    rotateFilledPolygon((int)width / 3 + 50, (int)height / 2 + 50, 30.0,points2, 4);  \n    gdImageFilledPolygon(img, 點2, 4, 紅色);  \n  \n    gdImagePngEx(img, 輸出檔, 9);  \n    fclose(輸出檔);  \n    gdImageDestroy(img);  \n  \n    返回0； \n} \n \n #include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n \n// 宣告旋轉函數 \nvoidrotateFilledPolygon(int x_orig, int y_orig, doublerotation_ang, gdPoint *points, int num_points) {  \nint i;  \n雙角度_rad = 旋轉_ang * M_PI / 180.0； \n \nfor (i = 0; i < num_points; i++) {  \nint x = 點[i].x - x_orig;  \nint y = 點[i].y - y_orig； \n \n點[i].x = x_orig + (int)(x * cos(angle_rad) - y * sin(angle_rad));  \n點[i].y = y_orig + (int)(x * sin(angle_rad) + y * cos(angle_rad));  \n}  \n}  \n \nint main() {  \nint 寬度 = 800;  \n整數高度=600； \n \ngdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  \ngdImageAlphaBlending(img, 0);  \n \nFILE *outputFile = fopen("./../images/hellogd2.png", "wb");  \nif (outputFile == NULL) {  \nfprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n返回1； \nint  \n \nred = gdImageColorAllocate(img, 255, 0, 0);  \nint 藍色 = gdImageColorAllocate(img, 0, 0, 255);  \nint black = gdImageColorAllocate(img, 0, 0, 0);  \nint 白色 = gdImageColorAllocate(img, 255, 255, 255);  \n \ngdImageFilledRectangle(img, 0, 0, 寬度, 高度, 白色);  \ngdImageFilledRectangle(img, 0, 0, (int)寬度 / 4, (int)高度 / 4, 藍色);  \n \ngdImageFilledEllipse(img, (int)寬度 * 3 / 4, (int)高度 / 4, (int)寬度 / 4, (int)寬度 / 4, 紅色);  \ngdImageEllipse(img, (int)寬度 * 3 / 4, (int)高度 * 3 / 4, (int)寬度 / 4, (int)寬度 / 4, 紅色);  \ngdImageLine(img, (int)寬度 / 2, (int)高度 / 2, (int)寬度 / 2, (int)高度 / 2 + 100, 藍色);  \n \ngdPoint點[4]； \n點[0].x = (int)寬度 / 4;  \n點[0].y = (int)高度 * 3 / 4;  \n點[1].x = 點[0].x + 100； \n點[1].y = 點[0].y;  \n點[2].x = 點[1].x； \n點[2].y = 點[1].y + 100； \n點[3].x = 點[2].x - 100； \n點[3].y = 點[2].y;  \n \n// 多次呼叫旋轉函數 \nfor (int i = 0; i < 4; i++) {  \nrotateFilledPolygon((int)width / 4 + 50, (int)height * 3 / 4 + 50, 30.0, points, 4) ;  \ngdImagePolygon(img, 點, 4, 黑色);  \n}  \n \ngdPoint 點2[4];  \n點2[0].x = (int)寬度/3;  \n點2[0].y = (int)高度/2;  \n點2[1].x = 點2[0].x + 100； \n點2[1].y = 點2[0].y;  \n點2[2].x = 點2[1].x;  \n點2[2].y = 點2[1].y + 100； \n點2[3].x = 點2[2].x - 150； \n點2[3].y = 點2[2].y;  \n \n// 多次呼叫旋轉函數 \nfor (int i = 0; i < 12; i++) { \n//旋轉填滿多邊形((int)寬度 / 3 + 50, (int)高度 / 2 + 50, 30.0, 點2, 4);  \n旋轉填充多邊形(500, 200, 30.0, 點2, 4);  \ngdImageFilledPolygon(img, 點2, 4, 紅色);  \ngdImagePngEx  \n \n(img, 輸出檔, 9);  \nfclose(輸出檔);  \ngdImageDestroy(img);  \n \n返回0； \n} \n \n', 'tags': '', 'url': 'w12.html'}, {'title': 'w13', 'text': '電腦程式設計這門課現在已經有一段時間了，一開始什麼都聽不懂，老師講課的速度也很快，而我自己是去反應比較慢的人，需要花多一點的時間老師講的內容，畢竟是第一次接觸C語言，我自己對這方面也不太拿手。剛開始上課幾週時設定Replit與GitHub帳號後不會完全知道進行後續的課程內容，經過多次觀看老師的影片及詢問同組同學和別組同學的結果讓我成功完成了老師指定的作業，也讓我對計畫語言有了進一步的認知。 \n', 'tags': '', 'url': 'w13.html'}, {'title': 'W15', 'text': '', 'tags': '', 'url': 'W15.html'}, {'title': '1個回答', 'text': '// https://en.wikipedia.org/wiki/Flag_of_the_Republic_of_China  \n// 內政部國旗參考資料：https://www.moi.gov.tw/cp.aspx?n=10621  \n// cc roc_flag_in_gd.c -lgd -lm 與gd 和數學庫連結 \n// https://www.rapidtables.com/web/color/RGB_Color.html  \n// 幾何形狀著色與繪圖練習 \n// 以下 gd 繪圖程式嘗試繪製 ROC 國旗，請以下規劃內容完成後續的國旗繪圖 \n#include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n   \nvoid draw_roc_flag(gdImagePtr img);  \nvoid draw_white_sun(gdImagePtr img, int x, int y, int size, int color);  \n   \nint main() {  \n    // 寬度 3: 高度 2  \n    int width = 1200;  \n    // 國旗長寬比為3:2  \n    int height = (int)(width*2.0 / 3.0);  \n   \n    gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  \n    gdImageAlphaBlending(img, 0);  \n   \n    繪製_roc_flag（img）； \n   \n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");  \n    if (outputFile == NULL) {  \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n        返回1； \n    gdImagePngEx  \n    (img, 輸出檔, 9);  \n    fclose(輸出檔);  \n    gdImageDestroy(img);  \n    返回0； \n}  \n   \nvoid draw_roc_flag(gdImagePtr img) {  \n    int width = gdImageSX(img);  \n    int 高度 = gdImageSY(img);  \n    int 紅、白、藍； \n    // 白日位於青天面積正中央，因此中心點座標為長寬各1/4處 \n    int center_x = (int)(width/4);  \n    int center_y = (int)(高度/4);  \n    // gdImageFilledEllipse 需以長寬方向的直徑作圖 \n    //由於中央白日圓形的半徑為青天寬度的1/8  \n    // 因此中央白日圓形的直徑為青天寬度的1/4，彩虹國旗寬度的1/8  \n    //還有白日十二道輻射的外圍圓形其半徑也是國旗寬度的1/8  \n    int sun_radius = (int)(width/8);  \n    // 中央白日圓形的直徑相當於十二道輻射外圍圓形的半徑 \n    int white_circle_dia = sun_radius;  \n    // 中央藍色圓形半徑為中央白日的1又2/15  \n    int blue_circle_dia = White_circle_dia + White_circle_dia*2/15;  \n    // 根據 https://www.moi.gov.tw/cp.aspx?n=10621 訂定國旗顏色值 \n    red = gdImageColorAllocate(img, 255, 0, 0);  // 紅色 \n    white = gdImageColorAllocate(img, 255, 255, 255);  // 白色 \n    藍色 = gdImageColorAllocate(img, 0, 0, 149);  // 藍色 \n    //依底部大小塗上紅色長方形區域 \n    gdImageFilledRectangle(img, 0, 0, width, height, red);  \n    // 青天為整面國旗的1/4，也採用長方形塗色 \n    gdImageFilledRectangle(img, 0, 0, (int)(width/2.0), (int)(height/2.0), blue);  \n    // 先設法填色畫出六個白色菱形 \n    draw_white_sun(img, center_x, center_y, sun_radius, White);  \n    //利用一個藍色大圓與白色小圓畫出藍色輪廓 \n    gdImageFilledEllipse(img, center_x, center_y, blue_circle_dia, blue_circle_dia, blue); \n    gdImageFilledEllipse（img，center_x，center_y，white_circle_dia，white_circle_dia，白色）； \n     \n}  \n   \nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {  \n    // M_PI 大小定義於 math.h 標頭檔中, 因為三角函數中採用徑度為角度單位// 因此將定義於 math.h 標頭檔中, 因為三角函數中採用徑度為角度單位 \n    // 因此將定義為角度轉為徑度的轉換變數為deg，角度值乘上deg就可轉為徑度 \n    float deg = M_PI/180;  \n    //依十二道輻射的每一尖角的角度為15度，求出其對應直角三角形的另一個角度為75度 \n    //求出十二道輻射中任一菱形的小半徑，菱形菱形另一個小圓的半徑大小 \n    float sr = sun_radius/tan(75*deg);  \n    int ax、ay、bx、by、dx、dy、ex、ey； \n    gdPoint點[4]； \n    /* 在塗上十二道輻射中的單一菱形區域之前，先以座標點畫線測試是否正確 \n    ax = center_x;  \n    ay = center_y - sun_radius； \n    bx = center_x - sun_radius*tan(15*deg);  \n    通過=中心_y； \n    前 = 中心_x;  \n    ey = center_y + sun_radius;  \n    dx = center_x + sun_radius*tan(15*deg);  \n    dy = 中心_y； \n    // AB  \n    gdImageLine(img, ax, ay, bx, by, color);  \n    // BE  \n    gdImageLine(img, bx, 由, ex, ey, color);  \n    // ED  \n    gdImageLine(img, ex, ey, dx, dy, 顏色);  \n    // DA  \n    gdImageLine(img, dx, dy, ax, ay, 顏色);  \n    */ \n    斧頭 = center_x;  \n    ay = center_y - sun_radius； \n    printf("%d,%d\\n",ax, ay);  \n    bx = center_x - sun_radius*tan(15*deg);  \n    通過=中心_y； \n    前 = 中心_x;  \n    ey = center_y + sun_radius;  \n    dx = center_x + sun_radius*tan(15*deg);  \n    dy = 中心_y； \n    // 確定單一菱形區域的塗色正確後，利用迴圈每次旋轉30度，總共轉六次即可塗上十二道光芒區域 \n    for (int i=1;i<=6;i++){  \n    / / A \n    點[0].x = ax+sun_radius*sin(30*deg*i);  \n    點[0].y = ay+sun_radius-sun_radius*cos(30*deg*i);  \n    printf("座標：(%d,%d)\\n", 點[0].x, 點[0].y);  \n    // B \n    點[1].x = bx+sr-sr*cos(30*deg*i);  \n    點[1].y = by-sr*sin(30*deg*i);  \n    printf("B座標：(%d,%d)\\n", 點[1].x, 點[1].y);  \n    // E \n    點[2].x = ex-sun_radius*sin(30*deg*i);  \n    點[2].y = ey-(sun_radius-sun_radius*cos(30*deg*i));  \n    printf("E座標: (%d,%d)\\n", 點[2].x, 點[2].y);  \n    // D \n    點[3].x = dx-(sr-sr*cos(30*deg*i));  \n    點[3].y = dy+sr*sin(30*deg*i);  \n    printf("D座標: (%d,%d)\\n\\n", 點[2].x, 點[2].y);  \n    // 為菱形區域範圍上色 \n    gdImageFilledPolygon(img,points,4,color);  \n    // 在菱形區域外圍畫線，明確表示菱形範圍 \n    gdImagePolygon(img,points,4,color);  \n    }  \n} \n \n A 座標：(429,125)  B 座標：(279,165)  E 座標：(170,274)  D 座標：(170,274) \n 方案內容所印出的六組ABED等對應ROC國旗白日圖案中的菱形四個關鍵點，請直接在青天與滿地紅的圖案中，利用白色作為畫線顏色，將第二組的ABED等四個點的座標，相連。 \n', 'tags': '', 'url': '1個回答.html'}, {'title': '2個回答', 'text': '#include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n  \nvoid draw_roc_flag(gdImagePtr img);  \n  \n// 函式原型 \nint lineCircleIntersection(int x1, int y1, int x2, int y2, int cx, int cy, int cr, int *x, int *y);  \n  \nint main() {  \n    int 寬度 = 1200;  \n    int 高度 = (int)(寬度 * 2.0 / 3.0);  \n  \n    gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  \n    gdImageAlphaBlending(img, 0);  \n  \n    繪製_roc_flag（img）； \n  \n    FILE *outputFile = fopen("roc_flag2.png", "wb");  \n    if (outputFile == NULL) {  \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n        返回1； \n    gdImagePngEx  \n    (img, 輸出檔, 9);  \n    fclose(輸出檔);  \n    gdImageDestroy(img);  \n    返回0； \n}  \n  \nvoid draw_roc_flag(gdImagePtr img) {  \n    int width = gdImageSX(img);  \n    int 高度 = gdImageSY(img);  \n    int 紅、白、藍； \n    int center_x = (int)(寬度/4);  \n    int center_y = (int)(高度 / 4);  \n  \n    紅色 = gdImageColorAllocate(img, 255, 0, 0);  \n    白色 = gdImageColorAllocate(img, 255, 255, 255);  \n    藍色 = gdImageColorAllocate(img, 0, 0, 149);  \n  \n    gdImageFilledRectangle(img, 0, 0, 寬度, 高度, 紅色);  \n    gdImageFilledRectangle(img, 0, 0, (int)(寬度 / 2.0), (int)(高度 / 2.0), 藍色);  \n  \n    int A_x = 429;  \n    int A_y = 125;  \n    int B_x = 279;  \n    int B_y = 165;  \n    整數E_x = 170;  \n    int E_y = 274;  \n    int D_x = 319;  \n    int D_y = 234;  \n  \n    // 繪製線條 \n    gdImageLine(img, A_x, A_y, B_x, B_y, White);  \n    gdImageLine(img, B_x, B_y, E_x, E_y, 白色);  \n    gdImageLine(img, E_x, E_y, D_x, D_y, 白色);  \n    gdImageLine(img, D_x, D_y, A_x, A_y, 白色);  \n  \n    // 太陽圓的座標 \n    int sun_center_x = (int)(width / 4);  \n    int sun_center_y = (int)(高度 / 4);  \n    int sun_radius = (int)(寬度/8);  \n  \n    // 畫出半徑減少的太陽圓 \n    int new_sun_radius = sun_radius / 2;  \n    gdImageFilledEllipse(img, sun_center_x, sun_center_y, new_sun_radius * 2, new_sun_radius * 2, 白色);  \n  \n    int 交集 1_x，交集 1_y； \n    int 交集2_x，交集2_y； \n    int 交集3_x，交集3_y； \n    int intersection4_x，intersection4_y； \n  \n    // 計算交點 \n    lineCircleIntersection(A_x, A_y, B_x, B_y, sun_center_x, sun_center_y, new_sun_radius, &intersection1_x, &intersection1_y); \n    lineCircleIntersection(B_x, B_y, E_x, E_y, sun_center_x, sun_center_y, new_sun_radius, &intersection2_x, &intersection2_y);  \n    lineCircleIntersection(E_x, E_y, D_x, D_y, sun_center_x, sun_center_y, new_sun_radius, &intersection3_x, &intersection3_y);  \n    lineCircleIntersection(D_x, D_y, A_x, A_y, sun_center_x, sun_center_y, new_sun_radius, &intersection4_x, &intersection4_y);  \n  \n    printf("交叉點 1: (%d, %d)\\n",intersection1_x,intersection1_y);  \n    printf("交叉點 2: (%d, %d)\\n",intersection2_x,intersection2_y);  \n    printf("交叉口 3: (%d, %d)\\n", junction3_x, junction3_y);  \n    printf("交叉點 4: (%d, %d)\\n", junction4_x, junction4_y);  \n}  \n  \n// 計算直線與圓相交的座標 \nint lineCircleIntersection(int x1, int y1, int x2, int y2, int cx, int cy, int cr, int *x, int *y) {  \n    float dx, dy, A , B、C、檢測、t； \n  \n    dx = x2 - x1;  \n    dy = y2 - y1； \n  \n    A = dx * dx + dy * dy;  \n    B = 2 * (dx * (x1 - cx) + dy * (y1 - cy));  \n    C = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - cr * cr;  \n  \n    det = B * B - 4 * A * C； \n  \n    if ((A <= 0.00001) || (det < 0)) {  \n        // 沒有實數解 \n        return 0;  \n    }  \n  \n    t = (-B - sqrt(det)) / (2 * A);  \n    *x = x1 + t * dx;  \n    *y = y1 + t * dy;  \n  \n    返回1； \n} \n \n A 座標：(351, 145)  B 座標：(317, 126)  C 座標：(247, 253)  D 座標：(280, 272) \n 承上題，請列出第二組ABED的四條直線與白日中的大圓所相交（相交）的四個點座標。 \n 試著詢問Chat GPT和嘗試執行程式的影片 \n', 'tags': '', 'url': '2個回答.html'}, {'title': '失敗的', 'text': '程式嘗試嘗試後輸出錯誤的圖形 \n #include <stdio.h>  \n#include <gd.h>  \n#include <math.h>  \n \nvoid draw_roc_flag(gdImagePtr img);  \nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color);  \nvoid findIntersectPoints(int center_x, int center_y, int radius, int i, gdPoint *points);  \n \nint main() {  \n    int 寬度 = 1200;  \n    int 高度 = (int)(寬度 * 2.0 / 3.0);  \n \n    gdImagePtr img = gdImageCreateTrueColor(寬度, 高度);  \n    gdImageAlphaBlending(img, 0);  \n \n    繪製_roc_flag（img）； \n \n    FILE *outputFile = fopen("roc_flag_in_gd.png", "wb");  \n    if (outputFile == NULL) {  \n        fprintf(stderr, "開啟輸出檔時發生錯誤。\\n");  \n        返回1； \n    gdImagePngEx  \n    (img, 輸出檔, 9);  \n    fclose(輸出檔);  \n    gdImageDestroy(img);  \n    返回0； \n}  \n \nvoid draw_roc_flag(gdImagePtr img) {  \n    int width = gdImageSX(img);  \n    int 高度 = gdImageSY(img);  \n    int 紅、白、藍； \n    int center_x = (int)(寬度/4);  \n    int center_y = (int)(高度 / 4);  \n \n    紅色 = gdImageColorAllocate(img, 255, 0, 0);  \n    白色 = gdImageColorAllocate(img, 255, 255, 255);  \n    藍色 = gdImageColorAllocate(img, 0, 0, 149);  \n \n    gdImageFilledRectangle(img, 0, 0, 寬度, 高度, 紅色);  \n    gdImageFilledRectangle(img, 0, 0, (int)(寬度 / 2.0), (int)(高度 / 2.0), 藍色);  \n \n    int sun_radius = (int)(寬度/8);  \n    draw_white_sun(img, center_x, center_y, sun_radius, 白色);  \n}  \n \nvoid draw_white_sun(gdImagePtr img, int center_x, int center_y, int sun_radius, int color) {  \n    float deg = M_PI / 180;  \n    float sr = sun_radius / tan(75 * deg);  \n    gdPoint點[4]； \n \n    for (int i = 1; i <= 6; i++) {  \n        findIntersectPoints(center_x, center_y, sun_radius, i, 點);  \n        gdImageLine(img, 點[0].x, 點[0].y, 點[1].x, 點[1].y, 顏色);  \n         \n        findIntersectPoints(center_x, center_y, sr, i, 點);  \n        gdImageLine(img, 點[1].x, 點[1].y, 點[2].x, 點[2].y, 顏色);  \n \n        findIntersectPoints(center_x, center_y, sun_radius, i + 1, 點);  \n        gdImageLine(img, 點[2].x, 點[2].y, 點[3].x, 點[3].y, 顏色);  \n \n        findIntersectPoints(center_x, center_y, sr, i + 1, 點);  \n        gdImageLine(img, 點[3].x, 點[3].y, 點[0].x, 點[0].y, 顏色);  \n    }  \n}  \n \nvoid findIntersectPoints(int center_x, int center_y, int radius, int i, gdPoint *points) { \n    浮點數 = M_PI / 180;  \n    浮動角度 = 30 * i * deg； \n \n    點[0].x = center_x + 半徑 * sin(角度);  \n    點[0].y = center_y - 半徑 + 半徑 * cos(角度);  \n \n    點[1].x = center_x + 半徑 * sin(角度 + 30 * deg);  \n    點[1].y = center_y - 半徑 + 半徑 * cos(角度 + 30 * 度);  \n \n    點[2].x = center_x + 半徑 * sin(角度 + 60 * deg);  \n    點[2].y = center_y - 半徑 + 半徑 * cos(角度 + 60 * 度);  \n \n    點[3].x = center_x + 半徑 * sin(角度 + 90 * deg);  \n    點[3].y = center_y - 半徑 + 半徑 * cos(角度 + 90 * 度);  \n} \n \n \n', 'tags': '', 'url': '失敗的.html'}, {'title': 'ANSIC', 'text': '', 'tags': '', 'url': 'ANSIC.html'}, {'title': 'ex.1', 'text': '#include <stdio.h>\n\nint main()  \n{\n    // Print Name\n    printf("Name   : 蔡福璟\\n"); \n\n    // Print Date of Birth\n    printf("DOB    : May 12,2005\\n"); \n\n    // Print Mobile Number\n    printf("Mobile : 09-06377799\\n"); \n\n    // Indicate successful execution\n    return(0); \n} \n \n', 'tags': '', 'url': 'ex.1.html'}, {'title': 'ex.2', 'text': '#include <stdio.h>\n\nint main()\n{\n    int days, years, weeks;\n\n    days = 1329; // Total number of days\n\n    // Converts days to years, weeks and days\n    years = days/365; // Calculate years\n    weeks = (days % 365)/7; // Calculate weeks\n    days = days - ((years*365) + (weeks*7)); // Calculate remaining days\n\n    // Print the results\n    printf("Years: %d\\n", years);\n    printf("Weeks: %d\\n", weeks);\n    printf("Days: %d \\n", days);\n\n    return 0;\n} \n \n', 'tags': '', 'url': 'ex.2.html'}, {'title': 'ex.3', 'text': '#include <stdio.h>\n\nint main() \n{\n    // Print a line of hashes\n    printf("######\\n");\n    \n    // Print a single hash\n    printf("#\\n");\n    \n    // Print a single hash\n    printf("#\\n");\n    \n    // Print a line of hashes\n    printf("#####\\n");\n    \n    // Print a single hash\n    printf("#\\n");\n    \n    // Print a single hash\n    printf("#\\n");\n    \n    // Print a single hash\n    printf("#\\n");\n\n    return(0);\n} \n \n #include <stdio.h>\n\nint main() \n{\n    // Print top line of pattern\n    printf("    ######\\n");\n    \n    // Print second line of pattern\n    printf("  ##      ##\\n");\n    \n    // Print lines 3 to 7 of pattern\n    printf(" #\\n");\n    printf(" #\\n");\n    printf(" #\\n");\n    printf(" #\\n");\n    printf(" #\\n");\n    \n    // Print bottom line of pattern\n    printf("  ##      ##\\n");\n    \n    // Print last line of pattern\n    printf("    ######\\n");\n\n    return(0);\n} \n \n', 'tags': '', 'url': 'ex.3.html'}, {'title': 'SSH', 'text': '下載膩子 \n 在putty資料夾內開啟puttygen.exe做一把金鑰匙 \n 將key儲存在github帳號內(開啟設定點選ssh) \n 返回puttygen.exe按儲存私鑰即可 \n 然後再打開膩子 \n 主機名稱輸入github.com \n 儲存的課程輸入自己的學號 \n \n 點選代理更改設定 \n \n 再點選ssh內的Auth裡面的Credentials \n \n 再匯出即可 \n', 'tags': '', 'url': 'SSH.html'}, {'title': '布萊頓', 'text': 'https://en.wikipedia.org/wiki/Python_（程式語言） \n 例子： \n https://gist.github.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d \n https://www.geeksforgeeks.org/python-programming-examples/ \n https://www.programiz.com/python-programming/examples \n https://www.freecodecamp.org/news/python-code-examples-sample-script-coding-tutorial-for-beginners/ \n Python教學： \n https://docs.python.org/3/tutorial/ \n Python 的非正式介紹 \n 縮排（Python 採用 4 個 Spaces 縮排，以介面執行範圍） \n 變數（ Python 關鍵字 ） \n 註（#單行註解、三單標註或三雙標註標註多行註解） \n 數 (整數 int(), 浮點數 float()) \n 字串 （字符串） \n print (Python 內建函數,  print() 函式) \n Python是控制流程工具 \n 為了 \n 如果 \n 範圍 \n 打開 \n 讀 \n 清單 \n 元組 \n 字典 \n 功能 \n 嘗試...除了 \n 休息 \n 經過 \n 類別 \n 此頁面示範如何在同一頁面下納入多個線上Ace編輯器與執行按鈕（ practice_html.txt 動態頁面超檔案）。 \n Practice_html.txt 動態頁面超檔案應該可以在啟動 Brython 時，設定會將 .py 檔案放入 downloads/py 目錄中引用。 \n 也即將所有對應的 html 也使用 Brython 產生，然後編寫為 類別 後，在範例匯入時透過 實例 引用。 \n <!-- 啟動 Brython -->  \n<script>  \nwindow.onload=function(){  \nbrython({debug:1, pythonpath:[\'./../cmsimde/static/\',\'./../downloads/py/\']}) ;  \n}  \n</腳本> \n 從1累加到100： \n 1 加到 100 \n 將 iterable 與 iterator 相關說明 ，利用 Brython 與 Ace Editor 整理在此頁面。 \n  導入 brython 程式庫  \n \n \n \n \n  啟動 Brython  \n \n \n \n  導入 FileSaver 與 filereader  \n \n \n \n \n  導入 ace  \n \n \n \n \n \n \n  導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫  \n \n \n \n \n \n \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n \n \n \n  add 1 to 100 開始  \n \n \n  add 1 to 100 結束 \n  editor1 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 檔案名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor1 結束   ##########################################  \n 從1累加到100第2部分： \n 1 加到 100 cango_三_齒輪 BS蛇 人工智慧俄羅斯方塊 旋轉塊 \n  請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱 \n \n \n \n  add 1 to 100 part2 開始  \n \n \n  add 1 to 100 part2 結束 \n  editor2 開始  \n  用來顯示程式碼的 editor 區域  \n \n  以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合  \n  存擋表單開始  \n 檔案名稱： .py   \n  存擋表單結束  \n \n  執行與清除按鈕開始  \n 跑步   輸出   明確輸出區 清晰的繪圖區 重新載入 \n  執行與清除按鈕結束  \n \n  程式執行 ouput 區  \n \n  Brython 程式執行的結果, 都以 brython_div1 作為切入位置  \n \n  editor2 結束  \n \n \n', 'tags': '', 'url': '布萊頓.html'}]};